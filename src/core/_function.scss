// ==========================================================================
// SECTION FUNCTIONS
// Functions required by several functions and mixins.
// ==========================================================================

@use 'sass:meta';
@use 'sass:string';
@use 'sass:list';
@use 'sass:map';
@use 'sass:math';

@use 'validation' as *;

/// --------------------------------------------------------------------------
/// Power function
/// @group utility
/// @author Sass
///
/// @arg {number} $base - number to be multiplied
/// @arg {number(unitless)} $exponents - number of times it should be multiplied
///
/// @returns {number}
/// @example
/// pow(10, 3)
/// > 1,000
/// --------------------------------------------------------------------------
@function pow(
  $base,
  $exponents
  ) {
  $_raised: 1;

  @for $_i from 1 through $exponents {
    $_raised: $_raised * $base;
  }
  @return $_raised;
}

/// --------------------------------------------------------------------------
/// String Explode
/// Splits a string at the indicated delimiter
/// @group utility
/// @author Nenad Novaković
///
/// @requires string.length (sass:string)
/// @requires string.slice (sass:string)
/// @requires string.index (sass:string)
/// @requires list.append (sass:list)
/// @requires meta.type-of (sass:meta)
/// @requires is-string (validation.scss)
///
/// @arg {string} $string The string to be split apart
/// @param {string} $delimiter Where to split the string
///
/// @returns {List}
/// @example:
/// str-explode('hello-world', '-')
/// > (hello, world)
/// --------------------------------------------------------------------------
@function str-explode(
  $string,
  $delimiter: ''
  ) {
  @if not is-string($string) {
    @error 'The argument $string: `#{$string}` is of incorrect type: `#{meta.type-of($string)}`. Type of `String` is required!';
  }
  @else if not is-string($delimiter) {
    @error 'The argument $string: `#{$string}` is of incorrect type: `#{meta.type-of($string)}`. Type of `String` is required!';
  }

  $_result: ();
  $_running: true;

  @if string.length($delimiter) == 0 {
    @for $i from 1 through string.length($string) {
      $_result: list.append($result, string.slice($string, $i, $i));
    }
    @return $_result;
  }

  @while $_running {
    $_index: string.index($string, $delimiter);

    @if $_index != null {
      $_item: string.slice($string, 1, ($_index - 1));
      $_result: list.append($_result, $_item);
      $string: string.slice($string, ($_index + string.length($delimiter)));
    }
    @else { $_running: false; }
  }

  @return list.append($_result, $string);
}

/// --------------------------------------------------------------------------
/// Deep Map Check
/// Check if nested map has a value by the keys
/// @group maps
/// @author Nenad Novaković
///
/// @requires map.has-key (sass:map)
/// @requires meta.type-of (sass:meta)
/// @requires map.get (sass:map)
/// @requires is-map (validation.scss)
///
/// @arg {map} $map - map to check
/// @arg {string(s)} $keys - keys in $map
///
/// @returns {boolean}
/// @example:
/// deep-map-check($nested-map, 'key-1', 'key-2')
/// > boolean
/// --------------------------------------------------------------------------
@function deep-map-check(
  $map,
  $keys...
  ) {
  @if not is-map($map) {
    @error 'The argument $map: "#{$map}" is of incorrect type: "#{meta.type-of($map)}". Type of "Map" is required!';
  }
  @each $key in $keys {
    @if not (map.has-key($map, $key)) {
      @return false;
    }
    $map: map.get($map, $key);
  }
  @return true;
}

/// --------------------------------------------------------------------------
/// Deep Map Get
/// Get a value from a nested map by the keys
/// @group maps
/// @author Nenad Novaković
///
/// @requires map.get (sass:map)
/// @requires meta.type-of (sass:meta)
/// @requires is-map (validation.scss)
///
/// @arg {map} $map - map to check
/// @arg {string(s)} $keys - keys in $map
///
/// @returns {Unspecified} it may return anything as a result
/// @example:
/// deep-map-check($nested-map, 'top-level-key', 'second-level-key')
/// > value of second level key
/// --------------------------------------------------------------------------
@function deep-map-get(
  $map,
  $keys...
  ) {
  @if not is-map($map) {
    @error 'The argument $map: "#{$map}" is of incorrect type: "#{meta.type-of($map)}". Type of "Map" is required!';
  }

  @each $key in $keys {
    $map: map.get($map, $key);
  }

  @return $map;
}

/// --------------------------------------------------------------------------
/// Get
/// Search for any value contained within nested maps by using dot notation
/// as the key argument
/// @group maps
/// @author Nenad Novaković
///
/// @requires str-explode
/// @requires deep-map-check
/// @requires deep-map-get
///
/// @arg {map} $map - map to check
/// @arg {string} $key - keys in $map
///
/// @returns {Unspecified} it may return anything as a result
/// @example
/// get($settings, border.radius.xs)
/// > value of the "xs" key
/// --------------------------------------------------------------------------
@function get($map, $key) {
  $keys: str-explode($key, ', ');

  @if not deep-map-check($map, $keys...) {
    @error 'The argument $map: "#{$map}" doesn\'t have some of the $keys: "#{$keys}"!';
  }

  @return deep-map-get($map, $keys...);
}

/// --------------------------------------------------------------------------
/// Recursive Map Merge
/// Search for any value contained within nested maps by using dot notation
/// as the key argument
/// @group maps
/// @author Zsolt Pentz
///
/// @requires map.has-key (sass:map)
/// @requires map.get (sass:map)
/// @requires map.merge (sass:map)
/// @requires meta.type-of (sass:meta)
///
/// @arg {map} $parent-map - map to override
/// @arg {map} $child-map - map with new values to merge
///
/// @returns {map} merged $parent-map and $child-map
///
/// DEPRECIATED: Code is no longer used
/// --------------------------------------------------------------------------
@function recursive-map-merge(
  $parent-map,
  $child-map
  ) {
	$_result: $parent-map;
	@each $_key, $_value in $child-map {
		@if ( not ( map.has-key($_result, $_key)) )
      or ( meta.type-of(map.get($_result, $_key)) != meta.type-of( $_value ) )
      or ( not ( (meta.type-of(map.get($_result, $_key)) ) == map and meta.type-of($_value) == map )) {
			$_result: map.merge($_result, ($_key: $_value));
		}
		@else {
			$_result: map.merge($_result, ($_key: recursive-map-merge(map.get($_result, $_key), $_value)));
		}
	}
	@return $_result;
}

/// --------------------------------------------------------------------------
/// Map Depth
/// Compute the maximum depth of a map
/// @group maps
/// @author Unknown
///
/// @requires is-map (validation.scss)
/// @requires math.max (sass:math)
///
/// @arg {Map} $map
///
/// @returns {Number} max depth of `$map`
/// --------------------------------------------------------------------------
@function map-depth(
  $map
  ) {
  $_level: 1;

  @each $_key, $_value in $map {
    @if is-map($_value) {
      $_level: math.max(map-depth($_value) + 1, $_level);
    }
  }
  @return $_level;
}

/// --------------------------------------------------------------------------
/// Strip Unit
/// Strips the unit from a number.
/// @group utility
/// @author Matthew McAdams
///
/// @arg {number} $value
///
/// @return {number (unitless)}
/// @example scss
///   $dimension: strip-unit(10em);
///
///   // Output
///   $dimension: 10;
/// --------------------------------------------------------------------------
@function strip-unit($value) {
  @return ($value / ($value * 0 + 1));
}

/// --------------------------------------------------------------------------
/// Convert Unit
/// Converts unit measurements
/// @group utility
/// @author Matthew McAdams
///
/// @requires math.unit (sass:math)
/// @requires math.percentage (sass:math)
/// @requires math.is-unitless (sass:math)
/// @requires config.$type-base (config.scss)
/// @requires strip-unit
///
/// @arg {number(with-unit)} $value - starting value to be converted
/// @arg {keyword['px'|'pt'|'%'|'em'|'rem']} $unit - unit to be converted to
/// @param {number(px)} $base [config.$type-base] - the px value of 1rem
///
/// @returns {number(with-unit)} $value conveted to $unit
/// --------------------------------------------------------------------------
@function convert($value, $unit, $base: map.get(config.$type-base, 'rem-size')) {
  $_current-unit: math.unit($value);
  $_value: strip-unit($value);
  @if not (math.is-unitless($base)) {
    @if math.unit($base) != px {
      @error "Not supported unit '#{math.unit($base)}' as convert base! Must be 'px'.";
    }
    $_base: strip-unit($base);
  }
  @if $_current-unit == 'px' {
    @if $unit == 'px' { @return $value; }
    @if $unit == 'em' { @return ($_value / $_base) + 0em; }
    @if $unit == 'rem' { @return ($_value / $_base) + 0rem; }
    @if $unit == '%' { @return math.percentage($_value / $_base); }
    @if $unit == 'pt' { @return ($value / 1.3333) + 0px; }
  }
  @if $_current-unit == '%' {
    @if $unit == 'px' { @return ($_value * $_base / 100) + 0px; }
    @if $unit == 'em' { @return ($strippedValue / 100) + 0em; }
    @if $unit == 'rem' { @return ($strippedValue / 100) + 0rem; }
    @if $unit == '%' { @return $value; }
    @if $unit == 'pt' { @return (($_value * $_base / 100) / 1.3333) + 0pt; }
  }
  @if ($_current-unit == 'em') or ($_current-unit == 'rem') {
    @if $unit == 'px' { @return ($_value * $_base) + 0px; }
    @if $unit == 'em' { @return $_value + 0em; }
    @if $unit == 'rem' { @return $_value + 0rem; }
    @if $unit == '%' { @return math.percentage($_value * $_base); }
    @if $unit == 'pt' { @return (($_value * $_base) / 1.3333) + 0pt; }
  }
  @if $_current-unit == 'pt' {
    @if $unit == 'px' { @return ($_value * 1.3333) + 0px; }
    @if $unit == 'em' { @return (($_value * 1.333) / $_base) + 0em; }
    @if $unit == 'rem' { @return (($_value * 1.333) / $_base) + 0rem; }
    @if $unit == '%' { @return math.percentage(($_value * 1.333) / $_base); }
    @if $unit == 'pt' { @return $value; }
  }
  @error "Can't convert '#{$value}' to unit '#{$unit}'!";
}

/// --------------------------------------------------------------------------
/// Modular Scale
/// Increments up or down a defined scale and returns an adjusted value.
/// @group typography
/// @author Matthew McAdams
///
/// @requires stratus.pow (functions.scss)
/// @requires config.$type-ratio (config.scss)
/// @requires get
///
/// @arg {number(unitless)} $increment
/// How many steps to increment up or down the scale.
/// @param {number(with unit)} $base [1em]
///   The base value the scale starts at.
/// @param {number (unitless)} $ratio [config.$type-ratio]
///   The ratio the scale is built on.

/// @returns {number(with-unit)}
/// --------------------------------------------------------------------------
@function modular-scale(
  $increment,
  $base: 1em,
  $ratio: config.$type-ratio
){
  @if $increment == 0 {
    @return $base;
  }
  @if $increment < 0 {
    // remove negative from number, division does this for us
    $increment: $increment * -1;
    @return $base / stratus.pow( $ratio, $increment );
  }
  @return $base * stratus.pow( $ratio, $increment );
}

// END !SECTION FUNCTIONS
